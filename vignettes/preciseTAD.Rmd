---
title: "preciseTAD Vignette"
author:
- name: Spiro Stilianoudakis
  affiliation:
  - &1 Department of Biostatistics, Virginia Commonwealth University, Richmond, VA
- name: Mikhail Dozmorov
  affiliation:
  - *1
date: '`r format(Sys.Date(), "%B %e, %Y")`'
abstract: >
  Chromosome conformation capture technologies combined with high-throughput 
  sequencing (Hi-C) have revealed that chromatin undergoes layers of
  compaction through DNA looping and folding, forming dynamic 3D structures.
  Among these are Topologically Associating Domains (TADs) and chromatin loops,
  which are known to play critical roles in cell dynamics like gene regulation 
  and cell differentiation. Precise identification of TAD/loop (domain) boundaries 
  remains difficult, as it is strongly reliant on Hi-C data resolution. Obtaining 
  genome-wide chromatin interactions at high-resolution is costly resulting 
  in low resolution of Hi-C matrices and high uncertainty in the location of 
  domain boundaries. We developed a machine learning framework that leverages 
  the spatial relationship of high-resolution genome annotation data (e.g.,
  ChIP-seq-defined transcription factor binding sites) to maximally accurately
  predict low-resolution domain boundaries. Translated on a base level, the model
  predicts the probability of each base being a boundary. These probabilities,
  coupled with density-based clustering  and scalable partitioning 
  techniques, allow the precise (base-level) identification of domain boundary
  regions and points. We show that known molecular drivers of 
  3D chromatin structures including CTCF, RAD21, and SMC3 are more enriched 
  at our predicted boundaries, as compared with the boundaries 
  identified by the popular Arrowhead TAD caller. The model trained 
  in one cell type can leverage genomic annotations and predict boundaries 
  in another cell type.
package: preciseTAD
output:
    BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{preciseTAD}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
    chunk_output_type: console
bibliography: references.bib
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
knitr::opts_chunk$set(warnings = FALSE, message = FALSE)
```

# Introduction

`preciseTAD` is an R package designed to transform domain boundary calling into a supervised machine learning framework. `preciseTAD` offers full functionality in building the predictor-response data and selecting the best model for precise prediction of boundary regions. This functionality can be broken into 2 primary usages:

+ Model building, and
+ Precise domain boundary prediction

## Input data

The training/testing data used for modeling is represented as a matrix with rows being genomic regions, columns being genomic annotations, and cells containing measures of association between them. Users have the option to concatenate genomic regions from multiple chromosomes.

To create the row-wise dimension of the data, `preciseTAD` uses *shifted binning*, a strategy for creating the dimensions of the data matrix used for modeling by segmenting the linear genome into nonoverlapping regions. This step is transparent for the user. To create shifted bins, chromosome-specific bins start at half of the resolution *r*, and continue in congruent intervals of length *r* until the end of the chromosome (*mod r* + *r/2*), using hg19 genomic coordinates. The shifted genomic bins, are then defined as boundary regions (*Y = 1*) if they contain a called boundary, and non-boundary regions (*Y = 0*) otherwise, thus establishing the binary response vector (**Y**) used for classification. Intuitively, shifted bins are centered on borders between the original bins, thus capturing potential boundaries. We found the shifted binning strategy improves model performance.

The column-wise dimension is formed by genomic annotations, such as transcription factor binding sites (TFBSs), histone modification marks, chromatin states. The *($log_{2}$) distances*, which enumerate the genomic distance from the center of each genomic bin to the center of the nearest ChIP-seq peak region of interest, are forming the feature space. Other feature type options include *binary overlaps* - an indicator for whether a ChIP-seq region overlaps with genomic bin, *count overlaps* - the number of overlaps in each bin, and *percent overlaps* - the percentage of overlap between any bin and the total width of all ChIP-seq regions overlapping it. The customized training/testing data formation offered by `preciseTAD` allows users to implement whichever binary classification machine learning algorithm of their choice. 

## preciseTAD functionality and output

`preciseTAD` implements a random forest (RF) model, allowing tuning hyperparameters and applying feature reduction. The primary inputs are the training and testing data, a list of hyperparameter values, the number of cross-validation folds to use (if a grid of hyperparameter values is provided), and the metric used for optimization. The output includes the model object (necessary for downstream prediction of boundaries), the variable importance values, and a list of performance metrics when validating the model on the testing data (see Table 1). This model is then used to predict base-level precise boundary locations.

To predict the base-level location of domain boundaries, the `preciseTAD` model is applied for each base annotated with the aforementioned genomic annotations. The base-level probabilities are clustered using density-based clustering and scalable data partitioning techniques, to narrow boundary regions and points. First, the probability vector, $p_{n_{i}}$, is extracted ($n_{i}$ representing the length of chromosome $i$). Next, *DBSCAN* (Density-based Spatial Clustering of Applications with Noise) [@ester1996density; @hahsler2019dbscan] is applied to the matrix of pairwise genomic distances between bases with $p_{n_{i}} \ge t$, where $t$ is a threshold determined by the user. The resulting clusters of highly predictive bases identified by DBSCAN are termed *preciseTAD boundary regions* (PTBR). To precisely identify a single base among each PTBR, *preciseTAD* implements an extension of partitioning around medoids (PAM), known as CLARA (Clustering Large Applications) for better scaling and more computational efficiency [@rousseeuw1990finding]. The corresponding cluster medoid is defined as a *preciseTAD boundary point* (PTBP), making it the most representative and biologically meaningful base within each clustered PTBR. The output includes a list of genomic coordinates of PTBPs and PTBSs.

[??? Describe how to predict boundaries in another cell type, should be detailed paragraph; !!!added]

Using the same model building and boundary prediction processes outlined above, `preciseTAD` provides functionality for predicting boundaries across cell types. Users can take advantage of the internal functions that create training and testing data sets (See Section 3.1.1) to build boundary prediction models in one cell type, to be used to make predictions in another cell type. The model building and prediction processes proceed similar to what is described in Section 1.1 and 1.2, the only difference is the cell type specific genomic annotations used to generate the base-level feature space, which the user can easily provide.

# Getting Started

## Installation

```{r, eval = FALSE}
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("preciseTAD")
devtools::install_github("dozmorovlab/preciseTAD")
# Alternatively
# devtools::install_github("stilianoudakis/preciseTAD")
```

```{r}
library(knitr)
library(e1071)
library(preciseTAD)
```

# Implementation

## Model building

### Construction of the data matrix

`preciseTAD` requires users to supply genomic coordinates of the "ground-truth" domain boundaries to establish the response vector (**Y**). As an example, we consider TAD boundaries derived from the popular *Arrowhead* TAD caller, a part of the Juicebox suite of tools developed by Aiden Lab [@durand2016juicer]. To get boundaries, *Arrowhead* was applied on the autosomal chromosomes using 5 kb GM12878 Hi-C data [@rao20143d] ([GSE63525](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE63525)). An example of the command line script used to called TADs with *Arrowhead* is provided below, as well as the first three columns of the resulting TAD coordinates. A more detailed tutorial for how to implement *Arrowhead* can be found [here](https://github.com/aidenlab/juicer/wiki/Arrowhead). 

[??? Include the code for Arrowhead you put in Additional File for the manuscript. Describe it; !!!added]

```{r, eval=FALSE}
arrowhead -c 1 \ #chromosome to call TADs on
  -r 5000 \ #HiC data resolution
  ~/GSE63525_GM12878_insitu_primary.hic \ #location of the .HIC file
  ~/arrowhead_output #location to store the output
```


```{r}
data("arrowhead_gm12878_5kb")
head(arrowhead_gm12878_5kb)
```

Users will then need to transform this TAD coordinate data into a GRanges object of unique boundary coordinates using the `preciseTAD::extractBoundaries()` function. Here we only extract boundaries for CHR1 and CHR22 (`CHR = c("CHR1", "CHR22")` parameter). We specify `preprocess=FALSE` because we are only interested in boundaries and not filtering TADs by length. Lastly, we specify `resolution=5000` to match the resolution used by *Arrowhead* (although this argument is ignored given that `preprocess=FALSE`). As shown below, there were a total of 1901 unique TAD boundaries reported by *Arrowhead* for chromosomes 1 and 22.

```{r}
bounds <- extractBoundaries(domains.mat = arrowhead_gm12878_5kb, preprocess = FALSE, CHR = c("CHR1", "CHR22"), resolution = 5000)
# View unique boundaries
bounds
```

To identify genomic annotations best predictive of TAD boundaries, `preciseTAD` requires functional genomic annotations. They are used to establish the feature space ($\textbf{X}=\{X_{1}, X_{2}, \cdots, X_{p} \}$). Cell type-specific genomic annotation data can be downloaded from [ENCODE](https://www.encodeproject.org/chip-seq-matrix/?type=Experiment&replicates.library.biosample.donor.organism.scientific_name=Homo%20sapiens&assay_title=TF%20ChIP-seq&status=released) as BED files. Once you have downloaded your preferred list of functional genomic annotations, store them in a specific file location (i.e. "./path/to/BEDfiles"). These files can then be converted into a GRangesList object and used to create the feature space using the `preciseTAD::bedToGRangesList()` function. The `signal` argument refers to the column in the BED files containing peak signal strength values and is used to assign metadata to the corresponding GRanges (only necessary for downstream plotting). As an example, we have already provided a GRangesList object with 26 transcription factor binding sites (TFBS) specific to the GM12878 cell type. Once you load it in, you can see the list of transcription factors using the following commands.

```{r}
# path <- "./path/to/BEDfiles"
# tfbsList <- bedToGRangesList(filepath=path, pattern = "*.bed", signal=4)

data("tfbsList")
names(tfbsList)
tfbsList
```

Using the "ground-truth" boundaries and the following TFBS, we can build the data matrix that will be used for predictive modeling. The `preciseTAD::createTADdata()` function can be used to create the training and testing data. Here, we specify to train on chromosome 1 and test on chromosome 22. Additionally, we specify `resolution = 5000` to construct 5kb shifted genomic bins (to match the Hi-C data resolution), `featureType = "distance"` for a ($log_2$) distance-type feature space, and `resampling = "rus"` to apply random under-sampling (RUS) on the training data to balance classes of boundary vs. non-boundary regions. We also specify a seed to ensure reproducibility when performing the resampling. The result is a list containing two data frames: (1) the resampled (if specified) training data, and (2) the testing data

```{r}
set.seed(123)
tadData <- createTADdata(bounds.GR = bounds,
                         resolution = 5000,
                         genomicElements.GR = tfbsList,
                         featureType = "distance",
                         resampling = "rus",
                         trainCHR = "CHR1",
                         predictCHR = "CHR22")

# View subset of training data
tadData[[1]][1:5,1:4]
# Check it is balanced
table(tadData[[1]]$y)

# View subset of testing data
tadData[[2]][1:5,1:4]
```

### Feature selection using recursive feature elimination

We can now implement our machine learning algorithm of choice to predict boundary regions. Here, we opt for the random forest algorithm for binary classification. `preciseTAD` offers functionality for performing recursive feature elimination (RFE) as a form of feature reduction through the use of the `preciseTAD::TADrfe()` function, which is a wrapper for the `rfe` function in the `caret` package [@kuhn2012caret]. `preciseTAD::TADrfe()` implements a random forest model on the best subset of features from 2 to the maximum number of features in the data by powers of 2, using 5-fold cross-validation. We specify accuracy as the performance metric. An example is shown below.

```{r results='hide'}
set.seed(123)
rfe_res <- TADrfe(trainData = tadData[[1]],
                 tuneParams = list(ntree = 500, nodesize = 1),
                 cvFolds = 5,
                 cvMetric = "Accuracy",
                 verbose = TRUE)
```

```{r}
# View RFE performances
rfe_res[[1]]

# View the variable importance among top n features across each CV fold
head(rfe_res[[2]])
```

Recursive feature elimination results indicate that model accuracy begins to stabilize when only considering the top four transcription factors for building random forest predictive models (Figure 1A). After aggregating the variable importance values of the top four TFBS across each cross-fold, we see that the top four most important TFBS in each of the five folds are the SMC3, RAD21, CTCF, and ZNF143 (Figure 1B). These are known components of the loop-extrusion model that has been proposed as a mechanism for the 3D architecture of the human genome [@sanborn2015chromatin; @fudenberg2016formation; @hansen2018recent]. 


![**Figure 1**. (A) Recursive feature elimination (RFE) indicates that performance stabilizes when only considering the top 4 most predictive transcription factor binding sites (TFBS). (B) Aggregate mean variable importance (using mean decrease in accuracy) for the top 4 TFBS across each of the 5 cross-folds.](figures/fig1_vignette.png)


### Implementing a random forest for boundary prediction

Now that we have suitably reduced our feature space, we can implement a random forest algorithm built simply on the TFBS mentioned above (SMC3, RAD21, CTCF, and ZNF143). To do so, we can take advantage of the `preciseTAD::TADrandomForest()` function, which is a wrapper of the `randomForest` package [@breiman2001random; @liaw2002classification]. We specify the training and testing data, the hyperparameter values, the number of cross-validation folds, the performance metric to consider (here, accuracy), the seed to initialize for reproducibility, an indicator for retaining the model object, an indicator for retaining variable importances, the variable importance measure to consider (here, mean decrease in accuracy (MDA)), and an indicator for retaining model performances based on the test data. A list of model performances are provided in Table 1 and can be accessed by running `tadModel[[3]]`.

```{r}
# Restrict the data matrix to include only SMC3, RAD21, CTCF, and ZNF143
tfbsList_filt <- tfbsList[names(tfbsList) %in% c("Gm12878-Ctcf-Broad", 
                                            "Gm12878-Rad21-Haib",
                                            "Gm12878-Smc3-Sydh",
                                            "Gm12878-Znf143-Sydh")]

set.seed(123)
tadData <- createTADdata(bounds.GR = bounds,
                         resolution = 5000,
                         genomicElements.GR = tfbsList_filt,
                         featureType = "distance",
                         resampling = "rus",
                         trainCHR = "CHR1",
                         predictCHR = "CHR22")

# Run RF
set.seed(123)
tadModel <- TADrandomForest(trainData = tadData[[1]],
                            testData = tadData[[2]],
                            tuneParams = list(mtry = 2,
                                              ntree = 500,
                                              nodesize = 1),
                            cvFolds = 3,
                            cvMetric = "Accuracy",
                            verbose = FALSE,
                            model = TRUE,
                            importances = TRUE,
                            impMeasure = "MDA",
                            performances = TRUE)
```

```{r}
# View model performances
performances <- tadModel[[3]]
performances$Performance <- round(performances$Performance, digits = 2)
rownames(performances) <- performances$Metric
kable(t(performances), caption = "List of model performances when validating an RF built on CHR1 on CHR22 test data.")
```

As you may know, there exist other machine learning binary classifiers that can be used in this setting. For example, suppose we opt to implement a support vector machine (SVM). This is easy enough to accomplish given that `preciseTAD::createTADdata()` conveniently sets up the training and testing data sets. We use the `e1071` package to run the SVM with a radial kernel, cost = 1, and gamma = 0.5 using the example command below. We see that the SVM model's accuracy is only 0.67, whereas the accuracy from our random forest was 0.69 (Table 1).

```{r}
svmModel <- svm(y ~ ., data = tadData[[1]], kernel = "radial", cost = 1, gamma = 0.5)

svmPreds <- predict(svmModel, tadData[[2]][, -1], positive = "Yes")

# Мiew confusion matrix
table(svmPreds, tadData[[2]][, 1])
```

## Precise boundary prediction

Recall that our model classifies boundary **regions**, in that each prediction refers to a genomic bin of width 5000 bases. To predict boundary coordinates at the base resolution more precisely, we can leverage our model through the use of the `preciseTAD::preciseTAD` function.  Conceptually, instead of genomic bins, we annotate each base with the selected genomic annotations and featureType and apply our model on this annotation matrix to predict the probability of each base is a boundary given the associated genomic annotations. To minimize computational costs, the base-level prediction should be performed in selected regions.

### Running preciseTAD

Suppose we want to precisely predict the domain boundary coordinates for the 2Mb section of CHR22:25,500,000-27,500,000. To do so, we specify `chromCoords = list(25500000, 27500000)`. Additionally, we set a threshold of 1.0 for constructing PTBRs using `threshold = 1.0`. We also specify 100 random samples to be used to partition the pairwise genomic distances used by CLARA. For DBSCAN, we assign 5000 and 3 for the $\epsilon$ and *MinPts* parameters.

```{r}
# Make sure the ground truth boundaries only include the CHR used to predict
bounds <- extractBoundaries(domains.mat = arrowhead_gm12878_5kb,
                              preprocess = FALSE,
                              CHR = "CHR22",
                              resolution = 5000)

# Run preciseTAD
set.seed(123)
pt <- preciseTAD(bounds.GR = bounds,
                genomicElements.GR = tfbsList_filt,
                featureType = "distance",
                CHR = "CHR22",
                chromCoords = list(25500000, 27500000),
                tadModel = tadModel[[1]],
                threshold = 1.0,
                flank = NULL,
                verbose = FALSE,
                parallel = FALSE,
                cores = NULL,
                splits = NULL,
                DBSCAN = TRUE,
                DBSCAN_params = list(5000, 3),
                method.Clust = NULL,
                PTBR = TRUE,
                CLARA = TRUE,
                method.Dist = "euclidean",
                samples = 100,
                juicer = FALSE)

# View the results
pt
```

The output of `preciseTAD::preciseTAD()` function is a list object with three elements: 1) the "ground-truth" called TAD boundary points (CTBP) used to train the model for the specified CHR (within the given region, if `chromCoord` is specified), 2) the `preciseTAD` predicted boundary points (PTBP), and 3) the `preciseTAD` predicted boundary regions (PTBR, if `PTBR=TRUE`). From the results above, we see that there were `r length(pt$CTBP)` called TAD boundary points by *Arrowhead* in the given section of CHR22. However, `preciseTAD` yielded `r length(pt$PTBP)` predicted boundary points.

### Cross cell type prediction

[??? Write a paragraph on how to predict boundaries in another cell type? I was thinking, one takes the model `tadModel[[1]]` trained in one cell type, the annotations `tfbsList_filt` of a cell type of interest, and that's it. But what is a cell type of interest does not have `bounds`, no Hi-C data, only annotations? That's the main selling point of your package, train a model once, then use only genomic annotations from other cell lines to predict boundaries in them.; !!!added]

Using built-in functions provided by `preciseTAD`, users can easily extend the model building and prediction processes described above to train and predict boundaries across cell types. To do so, users first build and train a boundary region prediction model on one cell type using `bedToGRangesList`, `extractBoundaries`, `createTADdata`, and `TADrandomForest` functions (See Section 3.1). Next, users will need to recreate genomic annotations from the other cell type as a GRanges object using the aforementioned `bedToGRangesList` function (i.e. creating another cell type specific `tfbsList_filt` object). This, with the `tadModel[[1]]` object that is created is all that is necessary to predict boundaries on the other cell type using `preciseTAD` (See Section 3.2).

### Using preciseTAD with Juicebox

Juicebox is an interface provided by Aiden Lab that allows for superimposing boundary coordinates onto Hi-C contact maps. To visualize domains flanked by the predicted boundaries, you must first select a Hi-C map. As an example, you can import the contact matrix for GM12878 derived by Rao et al. 2014 by choosing `File -> Open... -> Rao and Huntley et al. -> GM12878 -> in situ Mbol -> primary`. To format `preciseTAD` results to use in Juicebox, you must make sure to set `juicer=TRUE` in the function. 

```{r}
# Run preciseTAD
set.seed(123)
pt <- preciseTAD(bounds.GR = bounds,
                genomicElements.GR = tfbsList_filt,
                featureType = "distance",
                CHR = "CHR22",
                chromCoords = list(25500000, 27500000),
                tadModel = tadModel[[1]],
                threshold = 1.0,
                flank = NULL,
                verbose = FALSE,
                parallel = FALSE,
                cores = NULL,
                splits = NULL,
                DBSCAN = TRUE,
                DBSCAN_params = list(5000, 3),
                method.Clust = NULL,
                PTBR = TRUE,
                CLARA = TRUE,
                method.Dist = "euclidean",
                samples = 100,
                juicer = TRUE)

# View the results
pt$PTBP
```

You will then need to save the PTBPs as a BED file using `write.table` as shown below. Once saved, import them into Juicebox using `Show Annotation Panel -> 2D Annotations -> Add Local -> pt_chr22_255mb_275mb.bed`.

```{r, eval=FALSE}
pt_chr22_255mb_275mb <- pt$PTBP
filepath = "~/path/to/store/ptbps"
write.table(pt_chr22_255mb_275mb, 
            file.path(filepath, "pt_chr22_255mb_275mb.bed"),
            quote = FALSE,
            col.names = FALSE,
            row.names = FALSE,
            sep = "\t")
```

# References
